package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"time"

	"github.com/araddon/dateparse"
	"github.com/dghubble/go-twitter/twitter"
	"github.com/dghubble/oauth1"
)

// AutoGenerated struct declararion
type AutoGenerated []struct {
	Tweet struct {
		ID        string `json:"id"`
		CreatedAt string `json:"created_at"`
	}
}

// ConsumerKey for the Twitter app
const ConsumerKey = "xxx"

// ConsumerSecret for the Twitter app
const ConsumerSecret = "xxx"

// AccessToken for the Twitter app
const AccessToken = "xxx-xxx"

// AccessTokenSecret for the Twitter app
const AccessTokenSecret = "xxx"

// DateFrom defining the start date to search from
const DateFrom = "2011-01-31"

// DateTill defining the end date to search till
const DateTill = "2016-04-22"

func main() {

	// Create log file
	f, err := os.OpenFile("tweet-del.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatalln(err)
	}
	defer f.Close()

	logger := log.New(f, "tweet-del: ", log.LstdFlags)
	logger.Println("Initializing script")
	fmt.Println("Initializing script. Detailed transactions can be found in tweet-del.log")

	// // Our api keys and secrets
	config := oauth1.NewConfig(ConsumerKey, ConsumerSecret)
	token := oauth1.NewToken(AccessToken, AccessTokenSecret)

	// http.Client will automatically authorize Requests
	httpClient := config.Client(oauth1.NoContext, token)

	// Twitter client
	client := twitter.NewClient(httpClient)

	// Parse DateFrom constant
	fromDate, err := time.Parse("2006-01-02", DateFrom)
	if err != nil {
		logger.Fatalln("Cannot parse DateFrom into date format")
	}

	// ParseDateTill constant
	tillDate, err := time.Parse("2006-01-02", DateTill)
	if err != nil {
		logger.Fatalln("Cannot parse DateTill into date format")
	}
	logger.Printf("Deleting tweets between %v and %v\n", fromDate.Format("2006-01-02"), tillDate.Format("2006-01-02"))

	// Open the tweets.json file
	jsonFile, err := os.Open("tweet.json")

	if err != nil {
		logger.Fatalln("Couldn't open the tweet.json file", err)
	}
	logger.Println("Successfully opened tweet.json")

	// Defer the closing of the jsonFile so that we can parse it later on
	defer jsonFile.Close()

	// Read the opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	// Initialize the Tweet array
	var tweets AutoGenerated

	json.Unmarshal(byteValue, &tweets)

	logger.Println("Start deleting tweets ...")
	fmt.Println("Start deleting tweets ...")

	for i := 0; i < len(tweets); i++ {

		dateStamp, err := dateparse.ParseLocal(tweets[i].Tweet.CreatedAt)
		if err != nil {
			logger.Printf("Cannot parse CreatedAt, %v , (from API response) into date format\n", tweets[i].Tweet.CreatedAt)
		} else {
			// Format all dates
			dateStamp.Format("2006-01-02")
			fromDate.Format("2006-01-02")
			tillDate.Format("2006-01-02")

			if dateStamp.Before(tillDate) && dateStamp.After(fromDate) {
				// Parse string into int64
				tid, err := strconv.ParseInt(tweets[i].Tweet.ID, 10, 64)
				if err == nil {
					del, _, err := client.Statuses.Destroy(tid, &twitter.StatusDestroyParams{})
					if err != nil {
						// log.Fatal(err)
						logger.Printf("    Cannot find tweet with ID #%v\n", tid)
						continue
					}
					logger.Printf("    Successfully deleted tweet with ID #%v\n", del.ID)
				}
			}
		}
	}
	logger.Println("\nAll tweets successfully deleted")
	fmt.Println("All tweets successfully deleted")
}
